from copy import copy
from vector import Vector, Scalar, VectorType
from fd import fd
from matrix import Matrix, is_consistent, row_echelon_form
from basis import Basis
from typing import List, Union


class Subspace:
    """
    A linear subspace.

    Attributes:
        generators (List[Vector]): A list of the subspace's generators
        generator_matrix (Matrix): A Matrix whose columns are the subspace's generators
    """

    def __init__(self, *vectors: List[VectorType], **kwargs) -> None:
        """
        Parameters:
            *vectors (List[VectorType]): A list of the subspace's generators
            **kwargs:
                equations (List[List[Scalar]]): A list of coefficients of linear equations that generate the subspace
        """
        assert(all([len(v) == len(vectors[0]) for v in vectors]))
        if len(vectors) > 0:
            self.generators = [v if type(v) is Vector else Vector(v) for v in vectors]
        elif "equations" in kwargs:
            self.generators = Subspace(*kwargs["equations"]).equations()  # Double orthogonal complement
        if kwargs.get("remove_extra", False):
            self.remove_extra_generators()

    @property
    def generator_matrix(self) -> Matrix:
        """Creates the subspace's generator matrix"""
        return Matrix(cols=self.generators)

    def basis(self) -> Matrix:
        """Returns a basis for the subspace"""
        result = copy(self.generators)
        for i, v in enumerate(result):
            if is_consistent(Matrix(cols=result[:i] + result[i + 1:]), v):
                result.pop(i)
        return Basis(result)

    def dim(self) -> int:
        """Returns the subspace's dimension"""
        return len(self.get_base())

    def contains(self, other: Union[VectorType, "Subspace"]) -> bool:
        """Returns whether or not a vector or another subspace generated by the subspace"""
        if type(other) is Subspace:
            return all([self.contains(v) for v in other.generators])
        return is_consistent(self.generator_matrix, other)

    def remove_extra_generators(self) -> None:
        """Removes unnecesary Vectors from the list of generators"""
        self = self.get_base().get_subspace()

    def equations(self) -> List[List[Scalar]]:
        """Returns a list of coefficients of linear equations that generate the subspace"""
        m, transform = row_echelon_form(self.generator_matrix, True)
        return [transform[i] for i in range(m.size[0]) if all([n == 0 for n in m[i]])]

    def __add__(self, other: "Subspace") -> "Subspace":
        """Returns the sum of two Subspaces"""
        return Subspace(*(self.generators + other.generators))

    def intersection(self, other: "Subspace") -> "Subspace":
        """Returns the intersection between two Subspaces"""
        return Subspace(equations=self.equations() + other.equations())

    def __eq__(self, other: "Subspace") -> bool:
        """Returns wheter or not two subspaces are equal"""
        return all([self.contains(v) for v in other.generators]) and all([other.contains(v) for v in self.generators])

    def __repr__(self) -> str:
        """Returns a representation of the subspace"""
        return '<' + ", ".join([str(b) for b in self.generators]) + '>'

    def orthogonal_complement(self) -> "Subspace":
        """Returns the orthogonal complement of the subspace"""
        return Subspace(equations=self.generators)


fd["Subspace"] = Subspace

abc = "abcdefghijklmnopqrstuvwxyz"


class SolutionSpace:
    """
    A representation for the solution space of a non-homogenous set of linear equations.

    Attributes:
        origin (Vector): The solution's origin
        subspace (Subspace): A subspace containing the solution's generators
    """

    def __init__(self,
                 origin: VectorType,
                 *generators: List[VectorType]) -> None:
        """
        Parameters:
            origin (VectorType): The solution's origin
            generators (List[VectorType]): A list of the solution's generators
        """
        self.origin = origin if type(origin) is Vector else Vector(origin)
        self.subspace = Subspace(*generators)

    def contains(self, vector: VectorType) -> bool:
        """Returns whether or not the subspace contains a vector"""
        if type(vector) is not Vector:
            vector = Vector(vector)
        return self.subspace.contains(vector - self.origin)

    def __repr__(self) -> str:
        """Returns a representation of the solution space"""
        return str(self.origin) + ' + ' + ' + '.join([abc[i] + str(g) for i, g in enumerate(self.subspace.generators)])


def str_sign(n: Scalar) -> str:
    """Returns the symbol of the sign of a number"""
    return '-' if n < 0 else '+'


def pp_equations(equations: List[List[Scalar]]):
    """Pretty print a list of numbers that represent the coefficients of a linear homogeneous equation"""
    result = ""
    for eq in equations:
        result += ' '.join([f"{str_sign(n)} {abs(n) if abs(n) != 1 else ''}x{i + 1}" for i, n in enumerate(eq) if n != 0]) + " = 0\n"
    result = result[:-1]
    print(result)


r3 = Subspace([1, 0, 0], [0, 1, 0], [0, 0, 1])
s1 = Subspace([1, 0, 0], [1, 1, 0])
s2 = Subspace([1, 0, 1], [1, 1, 1], [2, 1, 2])
s3 = Subspace([0, 1, 0], [1, 0, 0])
s4 = Subspace([1, 1, 1], [2, 0, 2])
s5 = Subspace(equations=[[1, 1, 0], [0, 0, 1]])

r2 = Subspace([1, 0], [0, 1])
s6 = Subspace([1, -1])
ss1 = SolutionSpace([1, 1], [-1, 1])
